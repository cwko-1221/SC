<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>科學探究保衛戰 - V5.0 科學版</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @keyframes pulse-fast { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .animate-pulse-fast { animation: pulse-fast 1s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        
        body {
            background-color: #0f172a;
            color: white;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
        }
        #root { height: 100%; width: 100%; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ICONS (Science Themed) ---
        const IconBase = ({ children, size = 24, className = "", ...props }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>);
        const Heart = (p) => <IconBase {...p}><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/></IconBase>;
        const Shield = (p) => <IconBase {...p}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></IconBase>;
        const Play = (p) => <IconBase {...p}><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
        const Volume2 = (p) => <IconBase {...p}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></IconBase>;
        const VolumeX = (p) => <IconBase {...p}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></IconBase>;
        
        // Towers: Observation (Eye), Hypothesis (Bulb), Experiment (Flask/Beaker)
        const Eye = (p) => <IconBase {...p}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const Lightbulb = (p) => <IconBase {...p}><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-1 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></IconBase>;
        const Flask = (p) => <IconBase {...p}><path d="M10 2v7.31"/><path d="M14 2v7.31"/><path d="M8.5 2h7"/><path d="M14 9.3a6.5 6.5 0 1 1-4 0"/><path d="M5.52 16h12.96"/></IconBase>;

        // Currency
        const Atom = (p) => <IconBase {...p}><circle cx="12" cy="12" r="1"/><path d="M20.2 20.2c2.04-2.03.02-7.36-4.5-11.9-4.54-4.52-9.87-6.54-11.9-4.5-2.04 2.03-.02 7.36 4.5 11.9 4.54 4.52 9.87 6.54 11.9 4.5Z"/><path d="M15.7 15.7c4.52-4.54 6.54-9.87 4.5-11.9-2.03-2.04-7.36-.02-11.9 4.5-4.52 4.54-6.54 9.87-4.5 11.9 2.03 2.04 7.36.02 11.9-4.5Z"/></IconBase>;

        // Other UI
        const XCircle = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></IconBase>;
        const ArrowUpCircle = (p) => <IconBase {...p}><circle cx="12" cy="12" r="10"/><path d="m16 12-4-4-4 4"/><path d="M12 16V8"/></IconBase>;
        const Hand = (p) => <IconBase {...p}><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></IconBase>;
        const Beaker = (p) => <IconBase {...p}><path d="M4.5 3h15"/><path d="M6 3v16a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V3"/><path d="M6 14h12"/></IconBase>;

        // Enemies
        const Ghost = (p) => <IconBase {...p}><path d="M9 22v-2a2 2 0 0 1 4 0v2"/><path d="M9 22v-2a2 2 0 0 1 4 0v2"/><path d="M9 22v-2a2 2 0 0 1 4 0v2"/><path d="M18.5 12A6.5 6.5 0 0 0 5.5 12c0 2 .5 3.5 2.5 4.5v3c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2v-3c2-1 2.5-2.5 2.5-4.5Z"/><circle cx="10" cy="10" r="1"/><circle cx="14" cy="10" r="1"/></IconBase>;
        const Skull = (p) => <IconBase {...p}><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M8 20v2h8v-2"/><path d="m12.5 17-.5-1-.5 1h1z"/><path d="M16 20a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20"/></IconBase>;
        const Bug = (p) => <IconBase {...p}><rect width="8" height="12" x="8" y="6" rx="4"/><path d="m19 7-3 3"/><path d="m5 7 3 3"/><path d="m19 19-3-3"/><path d="m5 19 3-3"/><path d="M20 13h-4"/><path d="M4 13h4"/><path d="m10 4 1 2"/><path d="m14 4-1 2"/></IconBase>;
        const Flame = (p) => <IconBase {...p}><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.6-3.3.7-1.9 3.8-3.3 2.9-6.2Z"/></IconBase>;
        const Gem = (p) => <IconBase {...p}><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></IconBase>;
        const Bot = (p) => <IconBase {...p}><path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/></IconBase>;
        const CloudLightning = (p) => <IconBase {...p}><path d="M6 16.326A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 .5 8.973"/><path d="m13 12-3 5h4l-3 5"/></IconBase>;

        // --- CONSTANTS ---
        const GRID_W = 20;
        const GRID_H = 12;
        // Updated Tower Costs and Types
        const TOWER_COST = { observe: 100, hypothesis: 200, experiment: 300 };
        const PATH_LEFT=[{x:0,y:5},{x:1,y:5},{x:2,y:5},{x:3,y:5},{x:4,y:5},{x:5,y:5},{x:5,y:4},{x:5,y:3},{x:6,y:3},{x:7,y:3},{x:8,y:3},{x:9,y:3},{x:10,y:3},{x:10,y:4},{x:10,y:5},{x:11,y:5},{x:12,y:5},{x:13,y:5},{x:14,y:5},{x:15,y:5},{x:16,y:5},{x:17,y:5},{x:18,y:5},{x:19,y:5}];
        const PATH_TOP=[{x:8,y:0},{x:8,y:1},{x:8,y:2},{x:8,y:3},{x:9,y:3},{x:10,y:3},{x:10,y:4},{x:10,y:5},{x:11,y:5},{x:12,y:5},{x:13,y:5},{x:14,y:5},{x:15,y:5},{x:16,y:5},{x:17,y:5},{x:18,y:5},{x:19,y:5}];
        const PATH_BOTTOM=[{x:12,y:11},{x:12,y:10},{x:12,y:9},{x:12,y:8},{x:12,y:7},{x:12,y:6},{x:12,y:5},{x:13,y:5},{x:14,y:5},{x:15,y:5},{x:16,y:5},{x:17,y:5},{x:18,y:5},{x:19,y:5}];
        const ALL_PATHS = [PATH_LEFT, PATH_TOP, PATH_BOTTOM];

        const AudioEngine = {
          ctx: null, isMuted: false,
          init: () => { if (!AudioEngine.ctx) AudioEngine.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
          playTone: (freq, type, duration, vol = 0.1) => {
            if (AudioEngine.isMuted || !AudioEngine.ctx) return;
            const osc = AudioEngine.ctx.createOscillator(); const gain = AudioEngine.ctx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, AudioEngine.ctx.currentTime);
            gain.gain.setValueAtTime(vol, AudioEngine.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, AudioEngine.ctx.currentTime + duration);
            osc.connect(gain); gain.connect(AudioEngine.ctx.destination);
            osc.start(); osc.stop(AudioEngine.ctx.currentTime + duration);
          },
          playShoot: () => AudioEngine.playTone(400, 'square', 0.1, 0.05),
          playHit: () => AudioEngine.playTone(100, 'sawtooth', 0.1, 0.05),
          playBuild: () => AudioEngine.playTone(600, 'sine', 0.2, 0.1),
          playWin: () => { [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => setTimeout(() => AudioEngine.playTone(f, 'square', 0.3, 0.1), i * 100)); },
          toggleMute: () => { AudioEngine.isMuted = !AudioEngine.isMuted; return AudioEngine.isMuted; }
        };

        // --- NEW SCIENCE-ONLY QUESTION BANK (From Images) ---
        const FULL_QUESTION_BANK = [
          // Scientific Spirit & Attitudes
          { id: 1, qZh: "科學家應該具備甚麼精神？", qEn: "What spirit should scientists have?", options: [{t:"重視證據和事實 (Respect Evidence)",c:true}, {t:"盲目相信權威 (Blind Faith)",c:false}, {t:"固步自封 (Stubborn)",c:false}], expl: "科學家重視客觀證據，不被主觀偏見影響。" },
          { id: 2, qZh: "「不盲從權威」是甚麼意思？", qEn: "Meaning of 'Not bound by authority'?", options: [{t:"勇於挑戰舊有信念 (Challenge Old Beliefs)",c:true}, {t:"不聽老師的話 (Ignore Teachers)",c:false}, {t:"只相信自己 (Trust Self Only)",c:false}], expl: "敢於挑戰舊觀念，尋找新答案。" },
          { id: 3, qZh: "科學家如何對待實驗結果？", qEn: "How to treat experiment results?", options: [{t:"嚴謹測試和推理 (Strict Testing)",c:true}, {t:"隨意猜測 (Random Guess)",c:false}, {t:"忽視數據 (Ignore Data)",c:false}], expl: "進行仔細的實驗和詳細分析。" },
          { id: 4, qZh: "科學探究中「富想像力」重要嗎？", qEn: "Is 'Imagination' important?", options: [{t:"重要，助解決難題 (Yes, solve problems)",c:true}, {t:"不重要，只需數據 (No, just data)",c:false}, {t:"重要，用來幻想 (Yes, for dreaming)",c:false}], expl: "運用創新思維和新方法解決問題。" },
          { id: 5, qZh: "科學家應保持甚麼態度？", qEn: "Scientist's attitude?", options: [{t:"常存懷疑 (Always have doubts)",c:true}, {t:"輕易相信 (Easily believe)",c:false}, {t:"漠不關心 (Indifferent)",c:false}], expl: "不輕信，多思考求證。" },
          
          // Inquiry Process (Image 2 & 3)
          { id: 6, qZh: "科學探究的第一步通常是？", qEn: "First step of inquiry?", options: [{t:"觀察及提問 (Observe & Ask)",c:true}, {t:"進行測試 (Conduct Test)",c:false}, {t:"得出結論 (Conclusion)",c:false}], expl: "先觀察現象，然後提出問題。" },
          { id: 7, qZh: "「假設」是甚麼意思？", qEn: "What is a 'Hypothesis'?", options: [{t:"對問題的暫時解釋 (Temporary Explanation)",c:true}, {t:"最終的結論 (Final Conclusion)",c:false}, {t:"隨便的猜想 (Random Guess)",c:false}], expl: "根據知識或經驗提出的暫時性解釋，需驗證。" },
          { id: 8, qZh: "提出假設後，下一步是？", qEn: "Next step after Hypothesis?", options: [{t:"設計並進行測試 (Design Test)",c:true}, {t:"直接寫報告 (Write Report)",c:false}, {t:"放棄研究 (Give Up)",c:false}], expl: "需要透過科學方法驗證假設。" },
          { id: 9, qZh: "如果測試結果支持假設，我們可以？", qEn: "If result supports hypothesis?", options: [{t:"建立新知識 (Establish Knowledge)",c:true}, {t:"修改測試數據 (Change Data)",c:false}, {t:"推翻假設 (Overturn)",c:false}], expl: "經過分析確認後，可建立新知識。" },
          
          // Fair Testing (Image 5)
          { id: 10, qZh: "甚麼是「公平測試」？", qEn: "What is a 'Fair Test'?", options: [{t:"只改變一個變因 (Change 1 Variable)",c:true}, {t:"改變所有變因 (Change All)",c:false}, {t:"不改變任何變因 (Change None)",c:false}], expl: "只能有一個變因不同，其他需保持不變。" },
          { id: 11, qZh: "如果想測試「冰的大小」對融化速度的影響，應改變甚麼？", qEn: "Test 'Ice Size', change what?", options: [{t:"冰塊的大小 (Size of Ice)",c:true}, {t:"水的溫度 (Water Temp)",c:false}, {t:"杯子的物料 (Cup Material)",c:false}], expl: "要測試的因素就是唯一改變的變因。" },
          { id: 12, qZh: "在上述測試中，甚麼必須保持不變？", qEn: "What must keep SAME?", options: [{t:"水的溫度和分量 (Water Temp/Vol)",c:true}, {t:"冰的大小 (Ice Size)",c:false}, {t:"觀察者 (Observer)",c:false}], expl: "其他因素（如水溫）必須相同才公平。" },
          
          // History of Science (Image 4)
          { id: 13, qZh: "古人曾經相信地球是甚麼形狀？", qEn: "Ancient belief of Earth's shape?", options: [{t:"平的 (Flat)",c:true}, {t:"圓的 (Round)",c:false}, {t:"三角形 (Triangle)",c:false}], expl: "古代曾流行「地平說」。" },
          { id: 14, qZh: "甚麼證據推翻了「地平說」？", qEn: "Evidence overturning Flat Earth?", options: [{t:"衛星照片/航海 (Satellite/Sailing)",c:true}, {t:"古人的傳說 (Legends)",c:false}, {t:"個人的感覺 (Feelings)",c:false}], expl: "太空照片和環球航行證明地球是圓的。" },
          { id: 15, qZh: "科學知識會改變嗎？", qEn: "Does scientific knowledge change?", options: [{t:"會，隨新證據改變 (Yes, with evidence)",c:true}, {t:"不會，永遠不變 (No, never)",c:false}, {t:"看科學家心情 (Depends on mood)",c:false}], expl: "當發現新證據，舊知識會被修正或推翻。" },
          { id: 16, qZh: "這告訴我們甚麼科學精神？", qEn: "What spirit does this show?", options: [{t:"不被舊信念束縛 (Not bound by old beliefs)",c:true}, {t:"盲目相信古人 (Trust ancients)",c:false}, {t:"拒絕新事物 (Reject new)",c:false}], expl: "勇於挑戰舊信念，接受新證據。" },
          
          // Science in Daily Life (General from context)
          { id: 17, qZh: "觀察時，我們應該？", qEn: "When observing, we should?", options: [{t:"留心細節 (Pay attention to details)",c:true}, {t:"粗心大意 (Be careless)",c:false}, {t:"閉上眼睛 (Close eyes)",c:false}], expl: "細心觀察能發現別人忽略的事物。" },
          { id: 18, qZh: "如果檸檬茶裡的冰浮在上面，這是？", qEn: "Ice floating is?", options: [{t:"觀察到的現象 (Observation)",c:true}, {t:"假設 (Hypothesis)",c:false}, {t:"結論 (Conclusion)",c:false}], expl: "這是用感官直接獲得的資訊。" },
          { id: 19, qZh: "分析數據後，如果結果與假設不符，應該？", qEn: "If result != hypothesis?", options: [{t:"修正假設再測試 (Revise & Retest)",c:true}, {t:"修改實驗數據 (Fake Data)",c:false}, {t:"強行接受 (Force Accept)",c:false}], expl: "誠實面對結果，修正假設是科學過程。" },
          { id: 20, qZh: "學習科學的目的是？", qEn: "Purpose of learning science?", options: [{t:"建立新知識 (Establish Knowledge)",c:true}, {t:"為了考試 (For Exam)",c:false}, {t:"為了好玩 (Just Fun)",c:false}], expl: "探索世界，建立真確的知識。" }
        ];

        function App() {
          const [gameState, setGameState] = useState('menu');
          const [wave, setWave] = useState(1);
          const [money, setMoney] = useState(300); 
          const [lives, setLives] = useState(15); 
          const [draggedType, setDraggedType] = useState(null);
          const [dragPos, setDragPos] = useState({ x: 0, y: 0 });
          const [selectedTowerId, setSelectedTowerId] = useState(null);
          const [currentQ, setCurrentQ] = useState(FULL_QUESTION_BANK[0]); 
          const [feedback, setFeedback] = useState(null);
          const [isMuted, setIsMuted] = useState(false);
          const [, setTick] = useState(0);
          
          const questionDeckRef = useRef([]);
          const enemiesRef = useRef([]);
          const towersRef = useRef([]);
          const projectilesRef = useRef([]);
          const particlesRef = useRef([]);
          const lastTimeRef = useRef(0);
          const waveActiveRef = useRef(false);
          const enemiesSpawnedRef = useRef(0);
          const lastSpawnTimeRef = useRef(0);
          const requestRef = useRef(0);
          const boardRef = useRef(null);
          const boardContainerRef = useRef(null);

          const [scale, setScale] = useState(1);
          
          const updateScale = useCallback(() => {
            if (boardContainerRef.current) {
                const { width, height } = boardContainerRef.current.getBoundingClientRect();
                const targetRatio = GRID_W / GRID_H;
                const containerRatio = width / height;
                let newScale;
                if (containerRatio > targetRatio) {
                    newScale = height / (GRID_H * 40); 
                } else {
                    newScale = width / (GRID_W * 40);
                }
                setScale(newScale * 0.95); 
            }
          }, []);

          useEffect(() => {
            window.addEventListener('resize', updateScale);
            updateScale();
            return () => window.removeEventListener('resize', updateScale);
          }, [updateScale]);

          const isPath = (x, y) => ALL_PATHS.some(path => path.some(p => p.x === x && p.y === y));
          const isTower = (x, y) => towersRef.current.some(t => t.x === x && t.y === y);
          const isValidBuild = (x, y) => { if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H || isPath(x, y) || isTower(x, y) || (x >= 18 && y >= 4 && y <= 6)) return false; return true; };
          const getEnemyPos = (e) => { const path = ALL_PATHS[e.pathId]; const curr = path[e.pathIndex]; const next = path[e.pathIndex + 1] || curr; return { x: curr.x + (next.x - curr.x) * e.progress, y: curr.y + (next.y - curr.y) * e.progress }; };
          const pickNewQuestion = () => { if (questionDeckRef.current.length === 0) questionDeckRef.current = FULL_QUESTION_BANK.map((_, i) => i); const r = Math.floor(Math.random() * questionDeckRef.current.length); const q = questionDeckRef.current[r]; questionDeckRef.current.splice(r, 1); setCurrentQ(FULL_QUESTION_BANK[q]); };
          const toggleMute = () => { setIsMuted(AudioEngine.toggleMute()); };

          const animate = useCallback((time) => {
            if (lastTimeRef.current === 0) lastTimeRef.current = time;
            const deltaTime = time - lastTimeRef.current;
            lastTimeRef.current = time;
            const dtFactor = deltaTime / 16.67;

            if (waveActiveRef.current) {
              const totalEnemies = 8 + (wave * 3); 
              const spawnInterval = Math.max(400, 1600 - (wave * 100)); 
              if (enemiesSpawnedRef.current < totalEnemies) {
                if (time - lastSpawnTimeRef.current > spawnInterval) {
                  let pathId = 0;
                  if (wave >= 2 && Math.random() > 0.6) pathId = 1;
                  if (wave >= 3 && Math.random() > 0.7) pathId = 2;
                  let type = 'ghost'; let baseHp = 50 * Math.pow(1.18, wave); let baseSpeed = 0.0055 * Math.pow(1.05, wave); const rand = Math.random();
                  
                  if (wave >= 8 && rand > 0.97) { type = 'boss'; baseSpeed *= 0.4; baseHp *= 12; }
                  else if (wave >= 6 && rand > 0.9) { type = 'flame'; baseSpeed *= 2.0; baseHp *= 0.8; }
                  else if (wave >= 4 && rand > 0.8) { type = 'robot'; baseSpeed *= 0.5; baseHp *= 3.0; }
                  else if (wave >= 2 && rand > 0.85) { type = 'bat'; baseSpeed *= 1.8; baseHp *= 0.5; }
                  else if (wave >= 3 && rand > 0.75) { type = 'skull'; baseSpeed *= 0.7; baseHp *= 2.0; }
                  else if (wave >= 2 && rand > 0.6) { type = 'bug'; baseSpeed *= 1.4; baseHp *= 0.7; }

                  enemiesRef.current.push({ id: Math.random(), pathId, pathIndex: 0, progress: 0, hp: baseHp, maxHp: baseHp, speed: baseSpeed, type, visualOffset: 0 });
                  enemiesSpawnedRef.current++; lastSpawnTimeRef.current = time;
                }
              } else if (enemiesRef.current.length === 0) {
                waveActiveRef.current = false; if (wave < 12) setGameState('quiz'); else setGameState('victory'); AudioEngine.playWin();
              }
            }
            enemiesRef.current.forEach(e => { if (e.frozen && e.frozen > time) return; e.progress += e.speed * dtFactor; e.visualOffset = e.type === 'bat' ? Math.sin(time / 50) * 8 : Math.sin(time / 100) * 3; if (e.progress >= 1) { e.pathIndex++; e.progress = 0; const path = ALL_PATHS[e.pathId]; if (e.pathIndex >= path.length - 1) { e.hp = -1; setLives(l => { if (l - 1 <= 0) setGameState('gameover'); return l - 1; }); } } });
            towersRef.current.forEach(t => {
              if (time - t.lastFired > t.cooldown) {
                const target = enemiesRef.current.find(e => { if (e.hp <= 0) return false; const pos = getEnemyPos(e); const dist = Math.sqrt(Math.pow(pos.x - t.x, 2) + Math.pow(pos.y - t.y, 2)); return dist <= t.range; });
                if (target) {
                  if (t.type === 'experiment') { // Was Tech
                      particlesRef.current.push({ id: Math.random(), x: t.x+0.5, y: t.y+0.5, life: 10, color: 'cyan' }); 
                      const tPos = getEnemyPos(target); target.hp -= t.damage; 
                      const visualShiftY = (target.visualOffset || 0) / 40;
                      const freezeTime = (target.type === 'boss' || target.type === 'robot') ? 100 : 200; target.frozen = time + freezeTime; 
                      projectilesRef.current.push({ id: Math.random(), x: tPos.x+0.5, y: tPos.y+0.5 + visualShiftY, startX: t.x+0.5, startY: t.y+0.5, targetId: target.id, speed: 0, damage: 0, type: 'laser', life: 5 }); AudioEngine.playShoot(); 
                  } else { 
                      projectilesRef.current.push({ id: Math.random(), x: t.x + 0.5, y: t.y + 0.5, targetId: target.id, speed: 0.7, damage: t.damage, type: t.type === 'observe' ? 'box' : 'coin' }); AudioEngine.playShoot(); 
                  }
                  t.lastFired = time;
                }
              }
            });
            projectilesRef.current = projectilesRef.current.filter(p => { 
                if (p.type === 'laser') { p.life = (p.life || 0) - 1; return p.life > 0; } 
                const target = enemiesRef.current.find(e => e.id === p.targetId); 
                if (!target || target.hp <= 0) return false; 
                const pos = getEnemyPos(target); 
                const visualShiftY = (target.visualOffset || 0) / 40;
                
                const tx = pos.x + 0.5; const ty = pos.y + 0.5 + visualShiftY; 
                const dx = tx - p.x; const dy = ty - p.y; 
                const dist = Math.sqrt(dx*dx + dy*dy); 
                const moveDist = p.speed * dtFactor; 
                if (dist < moveDist) { 
                    target.hp -= p.damage; 
                    particlesRef.current.push({ id: Math.random(), x: tx, y: ty, life: 20, color: p.type === 'box' ? 'orange' : 'yellow' }); 
                    AudioEngine.playHit(); 
                    return false; 
                } else { 
                    p.x += (dx / dist) * moveDist; 
                    p.y += (dy / dist) * moveDist; 
                    return true; 
                } 
            });
            particlesRef.current.forEach(p => p.life -= 1 * dtFactor); particlesRef.current = particlesRef.current.filter(p => p.life > 0); enemiesRef.current = enemiesRef.current.filter(e => e.hp > 0);
            setTick(prev => prev + 1); if (gameState === 'playing') requestRef.current = requestAnimationFrame(animate);
          }, [gameState, wave]);

          useEffect(() => { AudioEngine.init(); if (gameState === 'playing') requestRef.current = requestAnimationFrame(animate); return () => cancelAnimationFrame(requestRef.current); }, [gameState, animate]);

          const handleDragStart = (type, e) => {
            if (e.type === 'touchstart') e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            if (money >= TOWER_COST[type]) { setDraggedType(type); setDragPos({ x: clientX, y: clientY }); setSelectedTowerId(null); }
          };

          useEffect(() => {
            if (!draggedType) return;
            const handleMove = (e) => {
                if (e.type === 'touchmove') e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setDragPos({ x: clientX, y: clientY });
            };
            const handleEnd = (e) => {
               const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
               const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
               if (boardRef.current) {
                   const rect = boardRef.current.getBoundingClientRect();
                   if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                       const x = Math.floor((clientX - rect.left) / (rect.width / GRID_W));
                       const y = Math.floor((clientY - rect.top) / (rect.height / GRID_H));
                       if (isValidBuild(x, y)) {
                           AudioEngine.playBuild();
                           let stats = { damage: 18, range: 3.5, cooldown: 550 }; 
                           if (draggedType === 'hypothesis') stats = { damage: 75, range: 4.5, cooldown: 1300 }; 
                           if (draggedType === 'experiment') stats = { damage: 4, range: 4, cooldown: 150 }; 
                           towersRef.current.push({ id: Math.random(), x, y, type: draggedType, level: 1, lastFired: 0, ...stats });
                           setMoney(prev => prev - TOWER_COST[draggedType]);
                       }
                   }
               }
               setDraggedType(null);
            };
            window.addEventListener('mousemove', handleMove); window.addEventListener('touchmove', handleMove, { passive: false });
            window.addEventListener('mouseup', handleEnd); window.addEventListener('touchend', handleEnd);
            return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('touchmove', handleMove); window.removeEventListener('mouseup', handleEnd); window.removeEventListener('touchend', handleEnd); };
          }, [draggedType]);

          const upgradeTower = () => { const t = towersRef.current.find(t => t.id === selectedTowerId); if (t && money >= 150) { setMoney(m => m - 150); t.level++; t.damage *= 1.3; setSelectedTowerId(null); AudioEngine.playBuild(); } };
          const sellTower = () => { const t = towersRef.current.find(t => t.id === selectedTowerId); if (t) { setMoney(m => m + Math.floor(TOWER_COST[t.type]*0.5)); towersRef.current = towersRef.current.filter(tx => tx.id !== selectedTowerId); setSelectedTowerId(null); } };
          const handleQuiz = (c) => { if(c) { setFeedback("經費批准！(Grant Approved!) +$200"); setTimeout(() => { setMoney(m=>m+200); setWave(w=>w+1); pickNewQuestion(); setGameState('playing'); enemiesSpawnedRef.current=0; waveActiveRef.current=true; setFeedback(null); }, 1000); } else { setFeedback("申請被拒... (Rejected) +$50"); setTimeout(() => { setMoney(m=>m+50); setWave(w=>w+1); pickNewQuestion(); setGameState('playing'); enemiesSpawnedRef.current=0; waveActiveRef.current=true; setFeedback(null); }, 1000); } };
          const startGame = () => { questionDeckRef.current = FULL_QUESTION_BANK.map((_, i) => i); pickNewQuestion(); setGameState('quiz'); setWave(1); setMoney(250); setLives(15); enemiesRef.current = []; towersRef.current = []; projectilesRef.current = []; AudioEngine.init(); };

          return (
            <div className="flex flex-col h-full w-full bg-slate-900 select-none overflow-hidden text-white">
              
              <div className="h-12 bg-slate-800 border-b border-slate-700 flex justify-between items-center px-4 shadow-md z-10 shrink-0">
                <div className="flex gap-4 items-center text-sm md:text-base">
                    <div className="flex items-center gap-1 text-red-400 font-bold"><Heart size={18} className="fill-current"/> {lives}</div>
                    <div className="flex items-center gap-1 text-yellow-400 font-bold"><Atom size={18} className="fill-current"/> {money}</div>
                    <div className="flex items-center gap-1 text-blue-400 font-bold"><Shield size={18}/> {wave}</div>
                </div>
                <div className="flex items-center gap-2">
                    <span className="hidden md:inline text-xs text-slate-400 font-bold uppercase border px-2 py-0.5 rounded">V5.0 SCIENCE</span>
                    <button onClick={toggleMute} className="text-slate-400 hover:text-white p-1">
                        {isMuted ? <VolumeX size={20}/> : <Volume2 size={20}/>}
                    </button>
                </div>
              </div>

              <div className="flex-1 flex items-center justify-center bg-slate-900 overflow-hidden w-full relative" ref={boardContainerRef}>
                
                <div 
                    ref={boardRef}
                    className="relative bg-slate-800 shadow-2xl border-2 border-slate-700 origin-center"
                    style={{
                        width: '800px',
                        height: '480px', 
                        transform: `scale(${scale})`, 
                        backgroundImage: `linear-gradient(to right, rgba(255,255,255,0.03) 1px, transparent 1px), linear-gradient(to bottom, rgba(255,255,255,0.03) 1px, transparent 1px)`,
                        backgroundSize: `40px 40px`
                    }}
                >
                    <svg className="absolute inset-0 w-full h-full pointer-events-none opacity-40">
                        {ALL_PATHS.map((path, i) => (
                            <polyline key={i} points={path.map(p => `${p.x*40 + 20},${p.y*40 + 20}`).join(' ')}
                                fill="none" stroke={i===0?"#ef4444":i===1?"#10b981":"#8b5cf6"} strokeWidth="16" strokeLinecap="round" strokeLinejoin="round" />
                        ))}
                    </svg>

                    <div className="absolute left-2 top-[35%] bg-red-500/80 px-2 py-1 rounded text-[10px] font-bold z-0">Path A</div>
                    <div className="absolute left-[35%] top-2 bg-green-500/80 px-2 py-1 rounded text-[10px] font-bold z-0">Path B</div>
                    <div className="absolute left-[55%] bottom-2 bg-purple-500/80 px-2 py-1 rounded text-[10px] font-bold z-0">Path C</div>

                    <div className="absolute right-[2%] top-[42%] w-[80px] h-[80px] flex items-center justify-center z-0">
                        <div className="w-14 h-14 bg-blue-600 rounded-full border-4 border-white flex items-center justify-center shadow-[0_0_10px_blue] animate-pulse">
                            <Beaker className="text-white w-8 h-8"/>
                        </div>
                    </div>

                    {towersRef.current.map(t => (
                        <div key={t.id} onClick={(e) => { e.stopPropagation(); setSelectedTowerId(t.id); }}
                            className={`absolute transition-transform z-10 flex items-center justify-center ${selectedTowerId===t.id?'scale-110 z-20':''}`}
                            style={{ left: t.x*40, top: t.y*40, width: 40, height: 40 }}
                        >
                            <div className={`w-[34px] h-[34px] rounded shadow-lg flex items-center justify-center border-b-4 transition-all duration-200
                                ${t.type==='observe'?'bg-orange-500 border-orange-700':t.type==='hypothesis'?'bg-yellow-500 border-yellow-700':'bg-cyan-500 border-cyan-700'}
                                ${selectedTowerId===t.id ? 'ring-2 ring-white' : ''}
                            `}>
                                {t.type==='observe' && <Eye size={20} className="text-white"/>}
                                {t.type==='hypothesis' && <Lightbulb size={20} className="text-white"/>}
                                {t.type==='experiment' && <Flask size={20} className="text-white"/>}
                            </div>
                            {t.level > 1 && <div className="absolute -top-1 -right-1 bg-black text-[10px] px-1 rounded-full border border-gray-600">Lv{t.level}</div>}
                        </div>
                    ))}

                    {enemiesRef.current.map(e => {
                        const pos = getEnemyPos(e);
                        return (
                            <div key={e.id} className="absolute z-20 flex flex-col items-center justify-center transition-none"
                                style={{ 
                                    left: pos.x*40, 
                                    top: pos.y*40,
                                    transform: 'translate(-50%, -50%)',
                                    marginTop: `${e.visualOffset}px`,
                                    width: 40, height: 40
                                }}
                            >
                                <div className="absolute -top-4 w-8 h-1.5 bg-gray-900 border border-gray-600 rounded-sm overflow-hidden">
                                    <div className="h-full bg-red-500 transition-all duration-100" style={{width: `${Math.max(0, (e.hp/e.maxHp)*100)}%`}}></div>
                                </div>
                                {e.type==='ghost' && <Ghost className="text-white drop-shadow-md w-8 h-8" />}
                                {e.type==='skull' && <Skull className="text-purple-400 drop-shadow-md w-8 h-8" />}
                                {e.type==='bug' && <Bug className="text-green-400 drop-shadow-md w-8 h-8" />}
                                {e.type==='flame' && <Flame className="text-orange-500 fill-orange-500 drop-shadow-md w-8 h-8" />}
                                {e.type==='boss' && <Gem className="text-pink-500 fill-pink-600 drop-shadow-xl w-10 h-10" />}
                                {e.type==='bat' && <CloudLightning className="text-yellow-300 drop-shadow-md w-8 h-8" />} 
                                {e.type==='robot' && <Bot className="text-blue-300 fill-slate-700 drop-shadow-md w-9 h-9" />}
                                {e.frozen && e.frozen > Date.now() && <div className="absolute inset-0 text-cyan-300 animate-pulse"><Zap size={24}/></div>}
                            </div>
                        )
                    })}

                    {projectilesRef.current.map(p => {
                        if (p.type === 'laser') {
                            return (
                            <svg key={p.id} className="absolute inset-0 w-full h-full pointer-events-none z-30">
                                <line x1={p.startX*40+20} y1={p.startY*40+20} x2={p.x*40+20} y2={p.y*40+20} stroke="cyan" strokeWidth="3" strokeOpacity="0.8" />
                            </svg>
                            )
                        }
                        return (
                            <div key={p.id} className="absolute w-3 h-3 bg-white rounded-full shadow-[0_0_8px_white] z-40 transition-none border border-black/20"
                                style={{ left: p.x*40, top: p.y*40, transform: 'translate(-50%, -50%)' }}
                            />
                        )
                    })}

                    {particlesRef.current.map(p => (
                        <div key={p.id} className="absolute w-6 h-6 rounded-full z-20 opacity-75"
                            style={{ 
                                left: p.x*40+20, top: p.y*40+20, 
                                transform: `translate(-50%, -50%) scale(${p.life/10})`,
                                backgroundColor: p.color
                            }}
                        />
                    ))}

                    {(gameState==='menu'||gameState==='gameover'||gameState==='victory') && (
                        <div className="absolute inset-0 bg-slate-900/95 z-50 flex flex-col items-center justify-center p-8 text-center">
                            <h1 className="text-5xl font-black mb-4 bg-gradient-to-r from-blue-400 to-indigo-500 bg-clip-text text-transparent">
                                {gameState==='menu'&&"科學探究保衛戰"}
                                {gameState==='victory'&&"實驗成功！"}
                                {gameState==='gameover'&&"實驗失敗..."}
                            </h1>
                            <button onClick={startGame} className="bg-indigo-600 px-8 py-3 rounded-full font-bold text-lg hover:bg-indigo-500 shadow-xl border-2 border-indigo-400 flex items-center gap-2">
                                <Play fill="currentColor" size={20}/> {gameState==='menu'?"開始研究 (Start)":"重試 (Retry)"}
                            </button>
                        </div>
                    )}

                    {gameState==='quiz' && (
                        <div className="absolute inset-0 bg-slate-900/95 z-50 flex items-center justify-center p-4">
                            <div className="bg-slate-800 p-6 rounded-2xl border border-slate-600 w-[90%] max-w-md text-center shadow-2xl">
                                <h2 className="text-xl font-bold mb-4 text-yellow-400 pb-2 border-b border-slate-700">申請研究經費 (Grant App)</h2>
                                {!feedback ? (
                                    <>
                                        <p className="text-lg font-medium mb-4">{currentQ.qZh}<br/><span className="text-xs text-slate-400">{currentQ.qEn}</span></p>
                                        <div className="grid gap-2">
                                            {currentQ.options.map((opt,i)=>(<button key={i} onClick={()=>handleQuiz(opt.c)} className="bg-slate-700 p-3 rounded-xl active:bg-blue-600 text-left font-bold border border-slate-600 text-sm">{opt.t}</button>))}
                                        </div>
                                    </>
                                ) : (
                                    <div className="text-2xl font-bold animate-bounce text-green-400 py-8">{feedback}</div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
              </div>

              <div className="h-24 bg-slate-900 border-t border-slate-700 shrink-0 w-full max-w-5xl mx-auto flex items-center gap-2 p-2">
                 <div className="bg-slate-800 rounded-xl border border-slate-700 p-2 flex-1 flex items-center gap-2 overflow-x-auto no-scrollbar shadow-lg touch-pan-x h-full">
                     <div className="text-slate-500 text-[10px] font-bold w-12 text-center leading-tight flex flex-col items-center flex-shrink-0"><Hand size={16} className="mb-1"/>拖曳<br/>Drag</div>
                     <div onTouchStart={(e)=>handleDragStart('observe',e)} onMouseDown={(e)=>handleDragStart('observe',e)} className={`relative p-2 rounded-lg bg-orange-900/30 border border-orange-500/50 w-20 h-full flex flex-col items-center justify-center flex-shrink-0 ${money<100?'opacity-50':''}`}>
                         <Eye size={24} className="text-orange-400 mb-1"/><span className="text-xs font-bold text-orange-200">觀察</span><span className="text-[10px] text-yellow-400">$100</span>
                     </div>
                     <div onTouchStart={(e)=>handleDragStart('hypothesis',e)} onMouseDown={(e)=>handleDragStart('hypothesis',e)} className={`relative p-2 rounded-lg bg-yellow-900/30 border border-yellow-500/50 w-20 h-full flex flex-col items-center justify-center flex-shrink-0 ${money<200?'opacity-50':''}`}>
                         <Lightbulb size={24} className="text-yellow-400 mb-1"/><span className="text-xs font-bold text-yellow-200">假設</span><span className="text-[10px] text-yellow-400">$200</span>
                     </div>
                     <div onTouchStart={(e)=>handleDragStart('experiment',e)} onMouseDown={(e)=>handleDragStart('experiment',e)} className={`relative p-2 rounded-lg bg-cyan-900/30 border border-cyan-500/50 w-20 h-full flex flex-col items-center justify-center flex-shrink-0 ${money<300?'opacity-50':''}`}>
                         <Flask size={24} className="text-cyan-400 mb-1"/><span className="text-xs font-bold text-cyan-200">實驗</span><span className="text-[10px] text-yellow-400">$300</span>
                     </div>
                 </div>
                 
                 <div className="bg-slate-800 rounded-xl border border-slate-700 p-1 w-20 h-full flex flex-col justify-center gap-1 shadow-lg shrink-0">
                     {selectedTowerId ? (
                         <>
                             <button onClick={upgradeTower} disabled={money<150} className={`flex-1 bg-green-600 rounded flex flex-col items-center justify-center p-1 ${money<150?'opacity-50':''}`}><ArrowUpCircle size={16}/><span className="text-[10px] font-bold">UP</span></button>
                             <button onClick={sellTower} className="flex-1 bg-red-600 rounded flex flex-col items-center justify-center p-1"><XCircle size={16}/><span className="text-[10px] font-bold">SELL</span></button>
                         </>
                     ) : <div className="text-slate-500 text-[10px] text-center px-1">點擊建築<br/>升級</div>}
                 </div>
              </div>

              {draggedType && (
                  <div className="fixed z-50 pointer-events-none transform -translate-x-1/2 -translate-y-1/2" style={{ left: dragPos.x, top: dragPos.y }}>
                      <div className="p-3 rounded-full bg-white/30 border-2 border-white backdrop-blur shadow-xl">
                          {draggedType==='observe' && <Eye size={32} className="text-orange-500"/>}
                          {draggedType==='hypothesis' && <Lightbulb size={32} className="text-yellow-500"/>}
                          {draggedType==='experiment' && <Flask size={32} className="text-cyan-500"/>}
                      </div>
                  </div>
              )}

            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>